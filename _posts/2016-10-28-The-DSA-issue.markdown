### What is DSA?

So, recently I was working on an issue where I had to extend the fingerprinting logic (which was only implemented for RSA at that time) for DSA. Hoping to do some research about the issue I just commited myself to that [issue](https://github.com/mozilla/ssh_scan/issues/216). 

![the_github_issue](../../images/the_dsa_issue/rsa_dsa.png)

> "The Digital Signature Algorithm (DSA) is a Federal Information Processing Standard for digital signatures. It was proposed by the National Institute of Standards and Technology (NIST) in August 1991 for use in their Digital Signature Standard (DSS) and adopted as FIPS 186 in 1993."  - **Wikipedia**

Well, Digital signatures are essential in today's modern world to verify the sender of a document's identity. A digital signature is represented in a computer as a string of binary digits. The signature is generated by use of private key and the private is only known to the user. The signature is verified by the public key which corresponds to the private key. With every user having a public/private key pair, this is an example of Public Key Cryptography. There are three algorithms that are suitable for digital signature generation under the DSS standard.  They are the Digital Signature Algorithm (DSA), the RSA algorithm, and the Elliptic Curve Digital Signature Algorithm (ECDSA).

So, after looking around for a bit and hunting down a few slides, blogs and pdfs. I got the main idea and came up with this for the testing part:  <br>

```ruby
  

    def test_dsa
     p = 718821195410015244146859624870715296017125527913000
         434010387577240100831644441209194543573159763837454
         2374929457672178957081124632837356913990200866056699
     q = 957032439192465935099784319494405376402293318491
     g = 122928973717064636255205666162891733518376475981809
         749897454444301389338825906076467196186192907631719
         698166056821519884939865041993585844526937010746285
     y = 123575618358346541478907331350272705707564117251418
         193873117202182514955196002970859605710210406339506
         3907739571546165975727369183495540798749742124846271
     algo = OpenSSL::ASN1::ObjectId.new('DSA')
     params = OpenSSL::ASN1::Sequence.new
              ([OpenSSL::ASN1::Integer.new(p),
                OpenSSL::ASN1::Integer.new(q),
                OpenSSL::ASN1::Integer.new(g)])
     algo_id = OpenSSL::ASN1::Sequence.new ([algo, params])
     pub_key = OpenSSL::ASN1::Integer.new(y)
     seq = OpenSSL::ASN1::Sequence.new([algo_id,
     	   OpenSSL::ASN1::BitString.new(pub_key.to_der)])
     key = OpenSSL::PKey::DSA.new(seq.to_der)
     assert(key.public?)
     assert(!key.private?)
     assert_equal(p, key.p)
     assert_equal(q, key.q)
     assert_equal(g, key.g)
     assert_equal(y, key.pub_key)
     assert_equal(nil, key.priv_key)
     assert_equal([], OpenSSL.errors)
    end

``` 
Here, `q` is a prime number which is called the *prime divisor* and `p` is another prime number, such `p - 1 mod q = 0`. `p` is called the *prime modulus*. 

`g` is chosen such that `1 < g < p`, 

`g`<sup>`q`</sup>` mod p = 1` and `g = h`<sup>`((pâ€“1)/q)`</sup>` mod p`

`y` is computed as `g`<sup>`x`</sup>` mod p`  <br>

`x` is chosen such that `0 < x < q`.


For the fingerprinting part, I was able to scan the hosts using the `ssh-keyscan` command. Something like this,

```bash
host_keys = `ssh-keyscan -t rsa,dsa #{target} 2>/dev/null`.split
```
Finally, got it merged into `master`. Phew. :sweat_smile:  

![the_merged_issue](../../images/the_dsa_issue/merged_dsa.png)

See you next time. :v:
